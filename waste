In firebase, i have data for blogposts which have the following form:
blog/blogid
{
  title: "A cool blog",
  content: "Once upon a time ...",
  likes: "522"
}

I also want to store comments for each blog. So we have in /stories/{storyid}/comments/{commentid}:
{
  user: "alice",
  content: "This is a cool story!",
  likes: "124"
}

How can i store and read a blogpost?

match /blogposts/{blogname} {
    allow read: if request.auth != null;
    allow write: if request.auth != null && request.resource.data.likedBy == resource.data.likedBy || request.resource.data.likedBy == resource.data.likedBy + [request.auth.uid];
}

To retrieve a limited number of comments for a blog post and then retrieve additional comments when the user clicks on an “expand” button, you can use Firestore’s pagination feature. This allows you to retrieve a subset of documents from a collection in a specific order and then retrieve additional documents starting from the last document in the previous set.

Here is an example of how you can write a getComments function that retrieves a limited number of comments for a given blog post:

async function getComments(blogname, limit, startAfter) {
    try {
        let query = collection(db, "comments").where("blogname", "==", blogname).orderBy("timestamp");
        if (startAfter) {
            query = query.startAfter(startAfter);
        }
        const querySnapshot = await getDocs(query.limit(limit));
        const comments = [];
        querySnapshot.forEach(doc => {
            comments.push(doc.data());
        });
        return comments;
    } catch (e) {
        console.error("Error getting comments: ", e);
        return [];
    }
}
This function takes three arguments: blogname, limit, and startAfter. The blogname argument represents the name of the blog post for which to retrieve comments. The limit argument specifies the maximum number of comments to retrieve. The startAfter argument is optional and specifies the document snapshot after which to start retrieving comments.

The function uses the collection, where, orderBy, startAfter, and limit functions to construct a query that retrieves a limited number of comments for the given blog post in order by their timestamp. If the startAfter argument is provided, it uses the startAfter function to start retrieving comments after the specified document snapshot. It then uses the getDocs function to execute the query and retrieve the comments. It stores the data of each comment in an array and returns it to the caller.

To use this function to implement an “expand” button for comments, you can call it initially with a limit value of 20 to retrieve the first 20 comments. When the user clicks on the “expand” button, you can call it again with the same limit value and pass in the last comment from the previous set as the startAfter argument. This will retrieve the next set of 20 comments starting from the last comment in the previous set.




oogle can index dynamic content generated by JavaScript 1. One way to help Google index your dynamic content is by creating a sitemap.xml of all your links and placing it at the root of your website 2. This can help Google find and index all of your pages. Is there anything else you would like to know?


service cloud.firestore {
    match /databases/{database}/documents {
      match /blogposts/{blogpostId} {
        allow update: if request.auth != null &&
                      request.resource.data.comments.size() < resource.data.comments.size() &&
                      request.resource.data.comments.toSet().hasAll(resource.data.comments.toSet()) &&
                      resource.data.comments.toSet().difference(request.resource.data.comments.toSet()).hasOnly([comment]) &&
                      comment.username == request.auth.uid;
      }
    }
  }




  async function addCommentToBlogPost(blogpostId, Ctext, Cdate, CUser) {
    const new_comment = {
      text: Ctext,
      likes: 0,
      username: CUser.displayName,
      IconUrl: CUser.photoURL,
      date: Cdate.toString(),
      replies: []
    };
    try {
      const blogpostRef = doc(db, "blogposts", blogpostId);
      // Generate a unique comment ID
      const commentId = `${CUser.uid}_${Cdate.getTime()}`;
      // Use the setDoc function with the merge option to add the new comment to the map
      await setDoc(blogpostRef, { comments: { [commentId]: new_comment } }, { merge: true });
      addNewComment(new_comment);
    } catch (error) {
      console.log("Error while adding comment: " + error);
      return error.toString();
    }
    return "ok";
  }

  export async function LikeComment(blogpostId, commentId) {
    try {
      const blogpostRef = doc(db, "blogposts", blogpostId);
      await runTransaction(db, async (transaction) => {
        const blogpostSnap = await transaction.get(blogpostRef);
        if (!blogpostSnap.exists()) {
          throw "Document does not exist!";
        }
        const blogpostData = blogpostSnap.data();
        const comments = blogpostData.comments;
        if (comments && comments[commentId]) {
          // Increment the likes field of the comment using a FieldValue
          transaction.update(blogpostRef, { [`comments.${commentId}.likes`]: increment(1) });
        } else {
          throw "Comment not found!";
        }
      });
    } catch (error) {
      console.log("Error while liking comment: " + error);
      return error.toString();
    }
    return "ok";
  }


  match /blogposts/{blogpostId} {
    allow read: if true;
    allow update: if request.auth.uid != null
                  && request.resource.data.comments[request.resource.data.commentId].likes == resource.data.comments[request.resource.data.commentId].likes + 1
                  && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['comments', 'commentId']);
  }


  IconUrl
: 
null
date
: 
"Wed Apr 26 2023 18:47:22 GMT+0200 (Mitteleuropäische Sommerzeit)"
"Wed Apr 26 2023 18:50:22 GMT+0200 (Mitteleuropäische Sommerzeit)"
lastLiked
: 
""
likes
: 
0
text
: 
"test"
userID
: 
"dCNrDzkhO7emkzFF9NzsslDQ8tP2"
"dCNrDzkhO7emkzFF9NzsslDQ8tP2"
username
: 
"invenis3@gmail.com"
[[Prototype]]
: 
Object

IconUrl
: 
null
date
: 

lastLiked
: 
""
likes
: 
0
text
: 
"test"
userID
: 

username
: 
"invenis3@gmail.com"